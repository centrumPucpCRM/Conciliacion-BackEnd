import csv
import io
import pandas as pd
import datetime
from typing import Dict, List, Any, Optional
from sqlalchemy.orm import Session
from fastapi import HTTPException

from ..models.usuario import Usuario
from ..models.cartera import Cartera
from ..models.programa import Programa
from ..models.oportunidad import Oportunidad
from ..models.propuesta import Propuesta
from ..models.tipo_cambio import TipoCambio
from ..models.propuesta_oportunidad import PropuestaOportunidad
from ..models.propuesta_programa import PropuestaPrograma
from ..models.rol_permiso import Rol

async def process_csv_data(db: Session, data: List[Dict[str, Any]]) -> Dict[str, Any]:
    """
    Procesa datos CSV de conciliación ya convertidos a formato JSON y crea los registros
    correspondientes en la base de datos.
    
    El proceso creará una única propuesta para todo el archivo CSV y asociará todas las 
    oportunidades a esa propuesta.
    """
    try:
        df = pd.DataFrame(data)
    except Exception as e:
        raise HTTPException(status_code=422, detail=f"Error al procesar los datos: {str(e)}")
    
    # Eliminar espacios en blanco de los nombres de columnas
    df.columns = df.columns.str.strip()
    
    # Reemplazar nombres de columnas para manejar posibles inconsistencias
    columns_mapping = {
        'usuario.nombre': 'usuario.nombre',
        'cartera.nombre': 'cartera.nombre',
        'programa.codigo': 'programa.codigo',
        'programa.nombre': 'programa.nombre',
        'progrma.fecha_de_inicio': 'programa.fecha_de_inicio',  # Corregir typo en el CSV
        'programa.fecha_de_inicio': 'programa.fecha_de_inicio',
        'programa.fecha_de_inauguracion': 'programa.fecha_de_inauguracion',
        'programa.fecha_ultima_postulante': 'programa.fecha_ultima_postulante',
        'programa.moneda': 'programa.moneda',
        'programa.precio_lista': 'programa.precio_lista',
        'oportunidad.nombre': 'oportunidad.nombre',
        'oportunidad.documento_identidad': 'oportunidad.documento_identidad',
        'oportunidad.correo': 'oportunidad.correo',
        'oportunidad.telefono': 'oportunidad.telefono',
        'oportunidad.etapa_venta': 'oportunidad.etapa_venta',
        'oportunidad.descuento': 'oportunidad.descuento',
        'oportunidad.moneda': 'oportunidad.moneda',
        'oportunidad.monto': 'oportunidad.monto'
    }
    
    # Aplicar el mapeo de columnas
    df = df.rename(columns={col: columns_mapping.get(col, col) for col in df.columns})
    
    # Convertir fechas
    date_columns = [
        'programa.fecha_de_inicio', 
        'programa.fecha_de_inauguracion', 
        'programa.fecha_ultima_postulante'
    ]
    
    for col in date_columns:
        if col in df.columns:
            df[col] = pd.to_datetime(df[col], errors='coerce', format='%d/%m/%Y')

    # Lista para almacenar resultados
    new_entities = {
        'usuarios': [],
        'carteras': [],
        'programas': [],
        'oportunidades': [],
        'propuestas': [],
        'tipo_cambios': [],
        'propuesta_oportunidades': [],
        'propuesta_programas': []
    }
    
    # Diccionarios para almacenar objetos únicos
    usuarios_dict = {}
    carteras_dict = {}
    programas_dict = {}
    
    # PASO 1: Crear una propuesta única para todo el archivo CSV con nombre que incluye fecha y hora actual
    now = datetime.datetime.now()
    timestamp_str = now.strftime("%Y%m%d_%H%M%S")
    propuesta_unica = Propuesta(
        nombre=f"Propuesta_{timestamp_str}",
        descripcion="Propuesta generada automáticamente desde archivo CSV",
        tipo_propuesta="CREACION",
        estado_propuesta="GENERADA",
        creado_en=now
    )
    db.add(propuesta_unica)
    db.flush()  # Asegurar que la propuesta tenga un ID
    
    new_entities['propuestas'].append({
        'id': propuesta_unica.id_propuesta,
        'nombre': propuesta_unica.nombre,
        'descripcion': propuesta_unica.descripcion
    })
import io
import pandas as pd
import datetime
from typing import Dict, List, Any, Optional
from sqlalchemy.orm import Session
from fastapi import HTTPException

from ..models.usuario import Usuario
from ..models.cartera import Cartera
from ..models.programa import Programa
from ..models.oportunidad import Oportunidad
from ..models.propuesta import Propuesta
from ..models.tipo_cambio import TipoCambio
from ..models.propuesta_oportunidad import PropuestaOportunidad
from ..models.propuesta_programa import PropuestaPrograma
from ..models.rol_permiso import Rol

async def process_csv_data(db: Session, data: List[Dict[str, Any]]) -> Dict[str, Any]:
    """
    Procesa datos CSV de conciliación ya convertidos a formato JSON y crea los registros
    correspondientes en la base de datos.
    
    El proceso creará una única propuesta para todo el archivo CSV y asociará todas las 
    oportunidades a esa propuesta.
    """
    try:
        df = pd.DataFrame(data)
    except Exception as e:
        raise HTTPException(status_code=422, detail=f"Error al procesar los datos: {str(e)}")
    
    # Eliminar espacios en blanco de los nombres de columnas
    df.columns = df.columns.str.strip()
    
    # Reemplazar nombres de columnas para manejar posibles inconsistencias
    columns_mapping = {
        'usuario.nombre': 'usuario.nombre',
        'cartera.nombre': 'cartera.nombre',
        'programa.codigo': 'programa.codigo',
        'programa.nombre': 'programa.nombre',
        'progrma.fecha_de_inicio': 'programa.fecha_de_inicio',  # Corregir typo en el CSV
        'programa.fecha_de_inicio': 'programa.fecha_de_inicio',
        'programa.fecha_de_inauguracion': 'programa.fecha_de_inauguracion',
        'programa.fecha_ultima_postulante': 'programa.fecha_ultima_postulante',
        'programa.moneda': 'programa.moneda',
        'programa.precio_lista': 'programa.precio_lista',
        'oportunidad.nombre': 'oportunidad.nombre',
        'oportunidad.documento_identidad': 'oportunidad.documento_identidad',
        'oportunidad.correo': 'oportunidad.correo',
        'oportunidad.telefono': 'oportunidad.telefono',
        'oportunidad.etapa_venta': 'oportunidad.etapa_venta',
        'oportunidad.descuento': 'oportunidad.descuento',
        'oportunidad.moneda': 'oportunidad.moneda',
        'oportunidad.monto': 'oportunidad.monto'
    }


    # Aplicar el mapeo de columnas
    df = df.rename(columns={col: columns_mapping.get(col, col) for col in df.columns})
    
    # Convertir fechas
    date_columns = [
        'programa.fecha_de_inicio', 
        'programa.fecha_de_inauguracion', 
        'programa.fecha_ultima_postulante'
    ]
    
    for col in date_columns:
        if col in df.columns:
            df[col] = pd.to_datetime(df[col], errors='coerce', format='%d/%m/%Y')

    # Lista para almacenar resultados
    new_entities = {
        'usuarios': [],
        'carteras': [],
        'programas': [],
        'oportunidades': [],
        'propuestas': [],
        'tipo_cambios': [],
        'propuesta_oportunidades': [],
        'propuesta_programas': []
    }
    
    # Diccionarios para almacenar objetos únicos
    usuarios_dict = {}
    carteras_dict = {}
    programas_dict = {}
    
    # PASO 1: Crear una propuesta única para todo el archivo CSV con nombre que incluye fecha y hora actual
    now = datetime.datetime.now()
    timestamp_str = now.strftime("%Y%m%d_%H%M%S")
    propuesta_unica = Propuesta(
        nombre=f"Propuesta_{timestamp_str}",
        descripcion="Propuesta generada automáticamente desde archivo CSV",
        tipo_propuesta="CREACION",
        estado_propuesta="GENERADA",
        creado_en=now
    )
    db.add(propuesta_unica)
    db.flush()  # Asegurar que la propuesta tenga un ID
    
    new_entities['propuestas'].append({
        'id': propuesta_unica.id_propuesta,
        'nombre': propuesta_unica.nombre,
        'descripcion': propuesta_unica.descripcion
    })
    
    # PASO 2: Eliminar usuarios con rol_id = 1 (si es necesario)
    try:
        usuarios_to_delete = db.query(Usuario).filter(Usuario.id_rol == 1).all()
        for usuario in usuarios_to_delete:
            db.delete(usuario)
        db.flush()
    except Exception as e:
        db.rollback()
        raise HTTPException(status_code=500, detail=f"Error al eliminar usuarios con rol 1: {str(e)}")
    
    # PASO 3: Identificar y crear carteras únicas
    unique_carteras = set()
    if 'cartera.nombre' in df.columns:
        unique_carteras = set(df['cartera.nombre'].dropna().unique())
    
    for cartera_nombre in unique_carteras:
        cartera_nombre = cartera_nombre.strip()
        # Verificar si la cartera ya existe en la base de datos
        cartera_existente = db.query(Cartera).filter(Cartera.nombre == cartera_nombre).first()
        
        if cartera_existente:
            carteras_dict[cartera_nombre] = cartera_existente
        else:
            # Crear nueva cartera
            cartera = Cartera(
                nombre=cartera_nombre,
                descripcion=f"Cartera creada desde CSV: {cartera_nombre}"
            )
            db.add(cartera)
            db.flush()
            carteras_dict[cartera_nombre] = cartera
            new_entities['carteras'].append({
                'id': cartera.id_cartera,
                'nombre': cartera_nombre
            })
    
    # PASO 4: Crear usuarios únicos con id_rol = 1 y establecer relación muchos-a-muchos con carteras
    # Obtener rol con id 1 (o el rol "Administrador" si existe)
    rol = db.query(Rol).filter(Rol.id_rol == 1).first()
    if not rol:
        rol = db.query(Rol).filter(Rol.nombre == "Administrador").first()
        
    if not rol:
        raise HTTPException(status_code=404, detail="No se encontró un rol adecuado para los usuarios")
    
    # Crear un mapeo de usuario->carteras
    usuario_carteras_map = {}
    
    for _, row in df.iterrows():
        if pd.notna(row.get('usuario.nombre')) and pd.notna(row.get('cartera.nombre')):
            usuario_nombre = row['usuario.nombre'].strip()
            cartera_nombre = row['cartera.nombre'].strip()
            
            if usuario_nombre not in usuario_carteras_map:
                usuario_carteras_map[usuario_nombre] = set()
            
            usuario_carteras_map[usuario_nombre].add(cartera_nombre)
    
    # Crear usuarios y asignarles carteras
    for usuario_nombre, cartera_nombres in usuario_carteras_map.items():
        # Verificar si el usuario ya existe
        usuario_existente = db.query(Usuario).filter(Usuario.nombres == usuario_nombre).first()
        
        if not usuario_existente:
            # Crear nuevo usuario con rol_id = 1
            usuario = Usuario(
                nombres=usuario_nombre,
                dni=f"USR{len(usuarios_dict) + 1}",
                correo=f"{usuario_nombre.lower().replace(' ', '.')}@ejemplo.com",
                celular="999999999",
                id_rol=rol.id_rol
            )
            db.add(usuario)
            db.flush()
            usuarios_dict[usuario_nombre] = usuario
            new_entities['usuarios'].append({
                'id': usuario.id_usuario,
                'nombres': usuario_nombre,
                'correo': usuario.correo
            })
        else:
            usuarios_dict[usuario_nombre] = usuario_existente
            
        # Asignar carteras al usuario
        usuario = usuarios_dict[usuario_nombre]
        for cartera_nombre in cartera_nombres:
            if cartera_nombre in carteras_dict:
                cartera = carteras_dict[cartera_nombre]
                # Verificar si la relación ya existe
                if cartera not in usuario.carteras:
                    usuario.carteras.append(cartera)
    
    # PASO 5: Crear programas únicos
    programas_dict = {}
    
    if 'programa.codigo' in df.columns:
        for _, row in df.iterrows():
            if pd.notna(row.get('programa.codigo')):
                programa_codigo = str(row['programa.codigo']).strip()
                
                if programa_codigo not in programas_dict:
                    # Verificar si el programa ya existe
                    programa_existente = db.query(Programa).filter(Programa.codigo == programa_codigo).first()
                    
                    if programa_existente:
                        programas_dict[programa_codigo] = programa_existente
                    else:
                        # Crear nuevo programa
                        programa_data = {
                            'codigo': programa_codigo,
                            'nombre': str(row.get('programa.nombre', '')).strip() if pd.notna(row.get('programa.nombre')) else f"Programa {programa_codigo}",
                            'moneda': str(row.get('programa.moneda', 'PEN')).strip() if pd.notna(row.get('programa.moneda')) else 'PEN',
                            'precio_lista': float(row.get('programa.precio_lista', 0)) if pd.notna(row.get('programa.precio_lista')) else 0,
                        }
                        
                        # Procesar fechas
                        try:
                            programa_data['fecha_de_inicio'] = row.get('programa.fecha_de_inicio').date() if pd.notna(row.get('programa.fecha_de_inicio')) else datetime.date.today()
                        except:
                            programa_data['fecha_de_inicio'] = datetime.date.today()
                            
                        try:
                            programa_data['fecha_de_inauguracion'] = row.get('programa.fecha_de_inauguracion').date() if pd.notna(row.get('programa.fecha_de_inauguracion')) else datetime.date.today()
                        except:
                            programa_data['fecha_de_inauguracion'] = datetime.date.today()
                            
                        try:
                            programa_data['fecha_ultima_postulante'] = row.get('programa.fecha_ultima_postulante').date() if pd.notna(row.get('programa.fecha_ultima_postulante')) else None
                        except:
                            programa_data['fecha_ultima_postulante'] = None
                        
                        programa = Programa(**programa_data)
                        db.add(programa)
                        db.flush()
                        programas_dict[programa_codigo] = programa
                        new_entities['programas'].append({
                            'id': programa.id_programa,
                            'codigo': programa_codigo,
                            'nombre': programa_data['nombre']
                        })
    
    # PASO 6: Crear tipos de cambio para monedas encontradas
    today = datetime.date.today()
    monedas = set()
    
    if 'programa.moneda' in df.columns:
        monedas.update([str(m).strip() for m in df['programa.moneda'].dropna().unique() if m != 'PEN'])
    
    if 'oportunidad.moneda' in df.columns:
        monedas.update([str(m).strip() for m in df['oportunidad.moneda'].dropna().unique() if m != 'PEN'])
        
    tipo_cambios = {}
    for moneda in monedas:
        if not moneda or moneda == 'PEN':
            continue
            
        # Asignar valores por defecto para conversión a PEN
        if moneda == 'USD':
            equivalencia = 3.75  # Valor ficticio para USD a PEN
        elif moneda == 'EUR':
            equivalencia = 4.10  # Valor ficticio para EUR a PEN
        else:
            equivalencia = 1.0  # Valor por defecto
        
        # Verificar si ya existe un tipo de cambio para esta moneda y fecha
        tipo_cambio_existente = db.query(TipoCambio).filter(
            TipoCambio.moneda_origen == moneda,
            TipoCambio.moneda_target == 'PEN',
            TipoCambio.fecha_tipo_cambio == today
        ).first()
        
        if not tipo_cambio_existente:
            tipo_cambio = TipoCambio(
                moneda_origen=moneda,
                moneda_target='PEN',
                equivalencia=equivalencia,
                fecha_tipo_cambio=today,
                creado_en=datetime.datetime.now()
            )
            db.add(tipo_cambio)
            db.flush()
            tipo_cambios[moneda] = tipo_cambio
            new_entities['tipo_cambios'].append({
                'id': tipo_cambio.id_tipo_cambio,
                'moneda_origen': moneda,
                'moneda_target': 'PEN',
                'equivalencia': equivalencia
            })
        else:
            tipo_cambios[moneda] = tipo_cambio_existente
                'moneda_target': 'PEN',
                'equivalencia': equivalencia,
                'fecha_tipo_cambio': today,
                'creado_en': datetime.datetime.now()
            })
        else:
            tipo_cambios[moneda] = tipo_cambio_existente
    
    # Procesar cada fila del CSV
    for _, row in df.iterrows():
        # Procesar Usuario
        if pd.notna(row.get('usuario.nombre')):
            usuario_nombre = row['usuario.nombre'].strip()
            if usuario_nombre not in usuarios_dict:
                # Verificar si el usuario ya existe en la base de datos
                usuario_existente = db.query(Usuario).filter(Usuario.nombres == usuario_nombre).first()
                if usuario_existente:
                    usuarios_dict[usuario_nombre] = usuario_existente
                else:
                    # Buscar un rol para el usuario (administrador por defecto)
                    from ..models.rol_permiso import Rol
                    rol = db.query(Rol).filter(Rol.nombre == "Administrador").first()
                    
                    # Crear nuevo usuario
                    usuario = Usuario(
                        nombres=usuario_nombre,
                        dni=f"USR{len(usuarios_dict) + 1}",  # DNI ficticio
                        correo=f"{usuario_nombre.lower().replace(' ', '.')}@ejemplo.com",  # Correo ficticio
                        celular="999999999",  # Celular ficticio
                        id_rol=rol.id_rol if rol else None  # Asignar rol si existe
                    )
                    db.add(usuario)
                    usuarios_dict[usuario_nombre] = usuario
                    new_entities['usuarios'].append({
                        'nombres': usuario_nombre,
                        'dni': usuario.dni,
                        'correo': usuario.correo,
                        'celular': usuario.celular,
                        'id_rol': usuario.id_rol
                    })
        
        # Procesar Cartera
        if pd.notna(row.get('cartera.nombre')):
            cartera_nombre = row['cartera.nombre'].strip()
            if cartera_nombre not in carteras_dict:
                # Verificar si la cartera ya existe en la base de datos
                cartera_existente = db.query(Cartera).filter(Cartera.nombre == cartera_nombre).first()
                if cartera_existente:
                    carteras_dict[cartera_nombre] = cartera_existente
                else:
                    # Crear nueva cartera
                    cartera = Cartera(
                        nombre=cartera_nombre
                    )
                    db.add(cartera)
                    carteras_dict[cartera_nombre] = cartera
                    new_entities['carteras'].append({
                        'nombre': cartera_nombre,
                    })
        
        # Procesar Programa
        if pd.notna(row.get('programa.codigo')):
            programa_codigo = str(row['programa.codigo']).strip()
            if programa_codigo not in programas_dict:
                # Verificar si el programa ya existe en la base de datos
                programa_existente = db.query(Programa).filter(Programa.codigo == programa_codigo).first()
                
                if programa_existente:
                    programas_dict[programa_codigo] = programa_existente
                else:
                    # Crear nuevo programa
                    programa_data = {
                        'codigo': programa_codigo,
                        'nombre': str(row.get('programa.nombre', '')).strip() if pd.notna(row.get('programa.nombre')) else f"Programa {programa_codigo}",
                        'moneda': str(row.get('programa.moneda', 'PEN')).strip() if pd.notna(row.get('programa.moneda')) else 'PEN',
                        'precio_lista': float(row.get('programa.precio_lista', 0)) if pd.notna(row.get('programa.precio_lista')) else 0
                    }
                    
                    # Procesar fechas
                    try:
                        programa_data['fecha_de_inicio'] = row.get('programa.fecha_de_inicio').date() if pd.notna(row.get('programa.fecha_de_inicio')) else datetime.date.today()
                    except:
                        programa_data['fecha_de_inicio'] = datetime.date.today()
                        
                    try:
                        programa_data['fecha_de_inauguracion'] = row.get('programa.fecha_de_inauguracion').date() if pd.notna(row.get('programa.fecha_de_inauguracion')) else datetime.date.today()
                    except:
                        programa_data['fecha_de_inauguracion'] = datetime.date.today()
                        
                    try:
                        programa_data['fecha_ultima_postulante'] = row.get('programa.fecha_ultima_postulante').date() if pd.notna(row.get('programa.fecha_ultima_postulante')) else None
                    except:
                        programa_data['fecha_ultima_postulante'] = None
                    
                    programa = Programa(**programa_data)
                    db.add(programa)
                    programas_dict[programa_codigo] = programa
                    new_entities['programas'].append(programa_data)
        # Crear una propuesta para esta oportunidad y programa
        propuesta_data = {
            'nombre': f"Propuesta para {oportunidad_data['nombre']}",
            'descripcion': f"Propuesta automática generada para la oportunidad {oportunidad_data['nombre']}",
            'tipo_propuesta': "CREACION",
            'estado_propuesta': "GENERADA",
            'creado_en': datetime.datetime.now()
        }
        
        propuesta = Propuesta(**propuesta_data)
        db.add(propuesta)
        db.flush()  # Asegurarse de que la propuesta tenga un ID
        new_entities['propuestas'].append(propuesta_data)
        # Procesar Oportunidad y sus relaciones
        if pd.notna(row.get('oportunidad.nombre')):
            oportunidad_data = {
                'nombre': str(row.get('oportunidad.nombre', '')).strip() if pd.notna(row.get('oportunidad.nombre')) else "",
                'documento_identidad': str(row.get('oportunidad.documento_identidad', '')).strip() if pd.notna(row.get('oportunidad.documento_identidad')) else "",
                'correo': str(row.get('oportunidad.correo', '')).strip() if pd.notna(row.get('oportunidad.correo')) else "",
                'telefono': str(row.get('oportunidad.telefono', '')).strip() if pd.notna(row.get('oportunidad.telefono')) else "",
                'etapa_venta': str(row.get('oportunidad.etapa_venta', '')).strip() if pd.notna(row.get('oportunidad.etapa_venta')) else "",
                'moneda': str(row.get('oportunidad.moneda', 'PEN')).strip() if pd.notna(row.get('oportunidad.moneda')) else 'PEN',
                'monto': float(row.get('oportunidad.monto', 0)) if pd.notna(row.get('oportunidad.monto')) else 0,
                'descuento': float(str(row.get('oportunidad.descuento', 0)).replace(',', '.')) if pd.notna(row.get('oportunidad.descuento')) else 0
            }
            
            # Crear oportunidad
            oportunidad = Oportunidad(**oportunidad_data)
            
            # Vinculación con Usuario si existe
            if pd.notna(row.get('usuario.nombre')):
                usuario_nombre = row['usuario.nombre'].strip()
                usuario = usuarios_dict.get(usuario_nombre)
                if usuario:
                    oportunidad.id_usuario = usuario.id_usuario
            
            # Vinculación con Cartera si existe
            if pd.notna(row.get('cartera.nombre')):
                cartera_nombre = row['cartera.nombre'].strip()
                cartera = carteras_dict.get(cartera_nombre)
                if cartera:
                    oportunidad.id_cartera = cartera.id_cartera
            
            db.add(oportunidad)
            db.flush()  # Asegurarse de que la oportunidad tenga un ID
            new_entities['oportunidades'].append(oportunidad_data)
            

            
            # Crear relación propuesta-oportunidad
            propuesta_oportunidad = PropuestaOportunidad(
                id_oportunidad=oportunidad.id_oportunidad,
                id_propuesta=propuesta.id_propuesta
            )
            db.add(propuesta_oportunidad)
            new_entities['propuesta_oportunidades'].append({
                'id_oportunidad': oportunidad.id_oportunidad,
                'id_propuesta': propuesta.id_propuesta
            })
            
            # Relacionar con programa si existe
            if pd.notna(row.get('programa.codigo')):
                programa_codigo = str(row['programa.codigo']).strip()
                programa = programas_dict.get(programa_codigo)
                if programa:
                    propuesta_programa = PropuestaPrograma(
                        id_programa=programa.id_programa,
                        id_propuesta=propuesta.id_propuesta
                    )
                    db.add(propuesta_programa)
                    new_entities['propuesta_programas'].append({
                        'id_programa': programa.id_programa,
                        'id_propuesta': propuesta.id_propuesta
                    })
    
    # Guardar cambios en la base de datos
    db.commit()
    
    return {
        "status": "success",
        "message": "CSV procesado con éxito",
        "data": {
            "nuevos_usuarios": len(new_entities['usuarios']),
            "nuevas_carteras": len(new_entities['carteras']),
            "nuevos_programas": len(new_entities['programas']),
            "nuevas_oportunidades": len(new_entities['oportunidades']),
            "nuevas_propuestas": len(new_entities['propuestas']),
            "nuevos_tipo_cambios": len(new_entities['tipo_cambios'])
        }
    }
